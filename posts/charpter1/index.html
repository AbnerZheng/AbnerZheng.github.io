<!DOCTYPE html>
<html lang="zh_cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="author" content="Abner Zheng">
<title>charpter1 | Abner Zheng's Blog</title>
<link href="../../assets/css/all.css" rel="stylesheet" type="text/css">
<!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js" type="text/javascript"></script>
    <![endif]--><link rel="alternate" type="application/rss+xml" title="RSS" href="../../rss.xml">
</head>
<body>
    <div id="wrp">
        <div id="cont">
            <div id="page">
                <header><h1>
                        <a href="https://abnerzheng.github.io/" title="Abner Zheng's Blog" rel="home">Abner Zheng's Blog</a>
                    </h1>
                </header><div id="body">
                    <nav><ul>
<li><a href="https://abnerzheng.github.io/" title="Home" rel="home"><i class="fa fa-fw fa-home"></i></a></li>
                            <li><a href="https://abnerzheng.github.io/categories/" title="Tags"><i class="fa fa-fw fa-tags"></i></a></li>
                            <li><a href="https://abnerzheng.github.io/rss.xml" title="RSS feed"><i class="fa fa-fw fa-rss"></i></a></li>
                            <li><a href="https://abnerzheng.github.io/pages/about" title="About"><i class="fa fa-fw fa-user"></i></a></li>
                            <li><a href="https://github.com/abnerzheng" title="My GitHub repo"><i class="fa fa-fw fa-github"></i></a></li>
                        </ul></nav><div id="content">
    <article class="post-text"><div class="h-entry" itemscope="itemscope" itemtype="http://schema.org/Article">
        <h1 class="p-name" itemprop="headline name">charpter1</h1>

    <small>
        Posted: <time class="published dt-published" datetime="2017-07-21T22:58:55+08:00" itemprop="datePublished">2017-07-21 22:58</time>
		          |  More posts about
            <a class="tag" href="../../categories/mathjax/"><span class="badge badge-info">mathjax</span></a>
            <a class="tag" href="../../categories/transaction/"><span class="badge badge-info">transaction</span></a>

    </small>
    <div class="e-content" itemprop="articleBody text">
    <div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">1</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">1.9 保存点和部分回滚</h3>
<div class="outline-text-3" id="text-1-1">
<p>
SQL的事务模型允许事务的部分提交：在前滚事务中的更新操作中的一个子集可以在不全部丢弃回滚整个事务的情况下回滚。 在执行了部分回滚后，在前滚阶段中余下的事务能够继续进行新的前滚操作。
</p>

<p>
部分回滚中要回滚的操作是由该事务的最后一次更新操作到上一个设置的保存点。保存点可以通过SQL语句来设置:
</p>

<div class="highlight"><pre><span></span><span class="k">set</span> <span class="n">savepoint</span> <span class="n">P</span>
</pre></div>

<p>
其中P是savepoint的一个独一名称。SQL语句
</p>

<div class="highlight"><pre><span></span><span class="k">rollback</span> <span class="k">to</span> <span class="n">savepoint</span> <span class="n">P</span>
</pre></div>

<p>
可以执行一个部分回滚到保存点P: 事务中在设置P后执行的未被撤销的所有前滚更新操作将会被撤销.
</p>

<p>
<b>例子1.10</b> 部分回滚可以嵌套
</p>

<div class="highlight"><pre><span></span><span class="k">insert</span> <span class="k">into</span> <span class="n">r</span> <span class="k">values</span> <span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="n">v_1</span><span class="p">);</span>
<span class="k">set</span> <span class="n">savepoint</span> <span class="n">P_1</span><span class="p">;</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">r</span> <span class="k">values</span> <span class="p">(</span><span class="n">x_2</span><span class="p">,</span> <span class="n">v_2</span><span class="p">);</span>
<span class="k">set</span> <span class="n">savepoint</span> <span class="n">P_2</span><span class="p">;</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">r</span> <span class="k">values</span> <span class="p">(</span><span class="n">x_3</span><span class="p">,</span> <span class="n">v_3</span><span class="p">);</span>
<span class="k">rollback</span> <span class="k">to</span> <span class="n">savepoint</span> <span class="n">P_2</span><span class="p">;</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">r</span> <span class="k">values</span> <span class="p">(</span><span class="n">x_4</span><span class="p">,</span> <span class="n">v_4</span><span class="p">);</span>
<span class="k">rollback</span> <span class="k">to</span> <span class="n">savepoint</span> <span class="n">P_1</span><span class="p">;</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">r</span> <span class="k">values</span> <span class="p">(</span><span class="n">x_5</span><span class="p">,</span> <span class="n">v_5</span><span class="p">);</span>
<span class="k">commit</span><span class="p">;</span>
</pre></div>

<p>
语句 <b>rollback to savepoint P<sub>2</sub></b> 从关系r中删除刚刚加入的元组(x<sub>3</sub>, v<sub>3</sub>)。语句 <b>rollback to savepoint P<sub>1</sub></b> 将删除刚刚天添加的(x<sub>4</sub>, v<sub>4</sub>)和(x<sub>2</sub>, v<sub>2</sub>)。 在事务的结尾， 一个初始空的关系r将只含有元组(x<sub>1</sub>, v<sub>1</sub>)和(x<sub>5</sub>,v<sub>5</sub>).
</p>

<p>
我们现在要将部分回滚加入到我们的事务模型中。为了该目的，我们定义了以下操作:
</p>

<ol class="org-ol">
<li value="7">S[P]: set savepoint P.
</li>
<li>A[P]: begin partial rollback to savepoint P.
</li>
<li>C[P]: complete the partial rollback to savepoint P.
</li>
</ol>
<p>
现在，在一个事务的前滚阶段Bα 中, α 可能包含set savepoint操作S[P], 完成的回滚操作 S[P]…A[P]…C[P], 或者一个已初始化但还未完成的部分回滚 S[P]…A[P]… 形式上来说， 一个事务的前滚阶段现在可以是以下三种形式中的任意一种:
</p>

<p>
(a) 一系列由R、I、D、W和S组成的操作
</p>

<p>
(b) 形如 \(\alpha S[P]\beta A[P] \beta^{-1}C[P]\gamma\) 的操作序列, 其中α , β 和 γ 是(a)或(b)的形式.
</p>

<p>
(c) 形如 \(\alpha S[P]\beta \delta A[P] \delta^{-1}\) 的操作序列,
</p>

<p>
在情形(b)中， 子序列 \(S[P]\beta A[P] \beta^{-1}C[P]\) 表示一个完成的回到保存点P的部分回滚。 在情形(c)中，子序列 \(S[P]\beta \delta A[P] \beta^{-1}\) 表示事务回滚到保存点P.
</p>

<p>
α 的撤销操作序列，表示为α<sup>-1</sup>或者undo(α), 是根据它的形式定义的: 对形式(a)中的序列α，它的撤销操作α<sup>1</sup>和之前的定义一样；对形式(b)中的一个序列，它的撤销操作序列是\(\gamma^{-1}\alpha^{-1}\). 对形式(c)中的序列，它的撤销序列是\(\beta^{-1}C[P]\alpha^{-1}\).
</p>

<p>
保存点和部分回滚组成了一个重要的数据库编程范式: 事务可以被随意用于立即更新数据库，即使一些接下来的事件强制回滚该更新，之后另一个事件完成该事务。 事实上,对于部分回滚，每个事务可以使用一个提交请求来终止而不需要使用回滚请求(比如说，完全回滚). 完全回滚的效果可以通过一下操作实现:在第一个更新前设置一个保存点，然后在结尾执行一个部分回滚到保存点, 然后提交该事务.
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">1.10 多粒度</h3>
<div class="outline-text-3" id="text-1-2">
<p>
我们可以扩展键范围事务,加入多粒度,因此元组可以被分组到不同关系中。数据库的关系组成一个集合，该集合根据它们的标识符全序排列。该集合可表示为:
</p>

<p>
$$\{(r_1,R_1),...,(r_{n_i}, R_{n_i})\}$$
</p>

<p>
其中，r<sub>i</sub> 是一个在数据库中唯一标识一个关系的标识符，R<sub>i</sub> 是关系模式(\(\underline{X_i}V_i\)). 由此，关系r中的元组(x, v)可由(r,x)来唯一标识。
</p>

<p>
事务模型中的逐元组前滚现在可以定义为:
</p>

<ol class="org-ol">
<li>\(R[r, x, \ge z, v]\): 读取在关系r中第一个满足 \(x\ge z\) 的元组(x,v)
</li>
<li>\(R[r, x, \gt z, v]\): 读取在关系r中z的下一个元组(x,v)
</li>
<li>\(W[r, x, u, v]\): 更新在关系r中的元组(x,v)
</li>
<li>\(I[r, x, v]\): 向关系r中插入元组(x,v)
</li>
<li>\(D[r, x, v]\): 在关系r中删除元组(x,v)
</li>
<li>
</li>
</ol>
<p>
新的操作包括:
</p>

<p>
(a) \(R[r', \theta r, R']\): 阅览关系$r'$中的模式\(R'\)
</p>

<p>
(b) \(I[r, R]\): 向数据库中创建一个新的关系r(R), 对应于SQL语句 <b>create table r(R)</b> .
</p>

<p>
(c) \(D[r, R]\): 从数据库中删除一个空的关系r, 对应于SQL语句 <b>drop table r</b>
</p>

<p>
额外的级别可以被加入到颗粒分级中，通过将关系分成不同数据库(为不同拥有者); 新的操作将包括这些对应于SQL语句 <b>create database</b> 和 <b>destroy database</b>.
</p>
</div>
</div>
</div>
    </div>
    </div>
            <ul class="pager">
<li class="previous">
                <a href="../stm/" rel="prev">← 前一篇</a>
            </li>
        </ul>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML">
      </script></article>
</div>
                </div>
                <div id="ftr">
                </div>
            </div>
        </div>
    </div>
	<footer><small>Contents © 2017         <a href="mailto:abnerzheng@gmail.com">Abner Zheng</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         </small>
	</footer>
</body>
</html>
